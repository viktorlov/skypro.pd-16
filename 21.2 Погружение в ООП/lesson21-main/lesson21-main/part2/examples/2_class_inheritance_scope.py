class A:
    a = 'кот'  # Родительский класс со строковой переменной a


class B(A):
    a = 1  # Дочерний класс с числовой переменной a

    def __init__(self, a=None):
        if a:
            self.a = a  # переменная объекта, которую мы можем инициализировать если захотим

    def kill_a(self):
        """Удаление переменной а из области вдимости класса B"""
        del B.a


b = B(a='не кот')

print('\nпри попытке обратиться к переменной а сначала будет произведен поиск внутри объекта, потом внутри класса, '
      'после этого внутри родительского класса\n')

print(b.a)

print('\nУдалим эту переменную из объекта и получим переменную класса B\n')

del b.a
print(b.a)

print()
print('=' * 20)
print('\nКак происходит поиск когда у нас несколько классов родителей\n')


class A:
    a = 'мама'


class B:
    a = 'мыла'
    b = 'кот'


class C:
    a = 'раму'
    b = 'не кот'
    c = 'сюда мы доберемся после проверок областей видимости классов A и B'


class Z(A, B, C):
    pass


z = Z()

print('\nСначала мы ищем переменную внутри области видимости объекта, потом внутри класса, а потом внутри '
      'родительских классов слева направо. То есть сначала мы поищем в z, после этого в Z, потом в A, B, C и или '
      'найдем нужную нам переменную или выбросим исключение. Так же нельзя забывать что у классов родителей могут '
      'быть свои родители и в их областях видимости поиск будет производиться по такому же правилу.\n')

print(z.a)
print(z.b)
print(z.c)

print('\nБудьте осторожны с множественным наследованием, вероятность что вы где то перекроете имя переменной или '
      'имя метода в сложном дереве наследования - очень и очень велика. А отдебажить такую ошибку будет весьма не '
      'просто\n')
